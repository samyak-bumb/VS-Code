// Created/Written by Tungsten
{
  "Boilerplate": {
    "prefix": "q",
    "body": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\t$0\n\t\n\treturn 0;\n}"
  },
  "zfor": {
    "prefix": "for",
    "body": "for (${1:size_t} ${2:i} = ${3:0}; ${2:i} < ${4:length}; ${2:i}++)\n{\n\t$5\n}"
  },
  "forr": {
    "prefix": "forr",
    "body": "for (int ${i} = ${1:length} - 1; ${i} >= ${2:0}; ${i}--)\n{\n\t$3\n}"
  },
  "do": {
    "prefix": "do",
    "body": "do\n{\n\t$1\n} while($2);"
  },
  "while": {
    "prefix": "while",
    "body": "while ($1)\n{\n\t$2\n}"
  },
  "foreach": {
    "prefix": "foreach",
    "body": "for(auto ${var} : ${collection_to_loop})\n{\n\t$1\n}"
  },
  "if": {
    "prefix": "if",
    "body": "if ($1)\n{\n\t$2\n}"
  },
  "else": {
    "prefix": "else",
    "body": "else\n{\n\t$1\n}"
  },
  "else if": {
    "prefix": "else if",
    "body": "else if ($1)\n{\n\t$2\n}"
  },
  "enum": {
    "prefix": "enum",
    "body": "enum ${MyEnum}\n{\n\t$1\n};"
  },
  "enum class": {
    "prefix": "enum class",
    "body": "enum class ${MyClass} { };"
  },
  "class": {
    "prefix": "class",
    "body": "class ${MyClass}\n{\npublic:\n\t${MyClass}();\n\t${MyClass}(${MyClass} &&) = default;\n\t${MyClass}(const ${MyClass} &) = default;\n\t${MyClass} &operator=(${MyClass} &&) = default;\n\t${MyClass} &operator=(const ${MyClass} &) = default;\n\t~${MyClass}();\n\nprivate:\n\t$1\n};\n\n${MyClass}::${MyClass}()\n{\n}\n\n${MyClass}::~${MyClass}()\n{\n}"
  },
  "classi": {
    "prefix": "classi",
    "body": "class ${MyClass}\n{\npublic:\n\t${MyClass}() = default;\n\t${MyClass}(${MyClass} &&) = default;\n\t${MyClass}(const ${MyClass} &) = default;\n\t${MyClass} &operator=(${MyClass} &&) = default;\n\t${MyClass} &operator=(const ${MyClass} &) = default;\n\t~${MyClass}() = default;\n\nprivate:\n\t$1\n};"
  },
  "interface": {
    "prefix": "interface",
    "body": "__interface I${Interface}\n{\n\t$1\n};"
  },
  "namespace": {
    "prefix": "namespace",
    "body": "namespace ${MyNamespace}\n{\n\t$1\n}"
  },
  "#ifdef": {
    "prefix": "#ifdef",
    "body": "#ifdef ${DEBUG}\n$1\n#endif // ${DEBUG}"
  },
  "#ifndef": {
    "prefix": "#ifndef",
    "body": "#ifndef ${1:1}\n$2\n#endif // !$1"
  },
  "#if": {
    "prefix": "#if",
    "body": "#ifdef ${1:0}\n$2\n#endif // $1"
  },
  "struct": {
    "prefix": "struct",
    "body": "struct ${MyStruct}\n{\n\t$1\n};"
  },
  "switch": {
    "prefix": "switch",
    "body": "switch (${switch_on})\n{\ndefault:\n\tbreak;$1\n}"
  },
  "try": {
    "prefix": "try",
    "body": "try\n{\n}\ncatch (const std::exception&)\n{\n\t$1\n}"
  },
  "union": {
    "prefix": "union",
    "body": "union ${MyUnion}\n{\n\t$1\n};"
  },
  "cout": {
    "prefix": "cout",
    "body": "cout << $1 << endl;"
  },
  "cin": {
    "prefix": "cin",
    "body": "cin >> $0;"
  },
  "#inc": {
    "prefix": "#inc",
    "body": "#include \"$1\""
  },
  "#inc<": {
    "prefix": "#inc<",
    "body": "#include <$1>"
  },
  "#def": {
    "prefix": "#def",
    "body": "#define \"$1\" \"$2\""
  },
  "main": {
    "prefix": "main",
    "body": "int main(int argc, const char** argv) {\n\treturn 0;\n}"
  },
  "int": {
    "prefix": "int",
    "body": "int $0;"
  },
  "char": {
    "prefix": "char",
    "body": "char $0;"
  },
  "comment_block": {
    "prefix": "comment_block",
    "body": "/**\n *\n * ${1:Block comment}\n *\n */\n\n${0}"
  },
  "comment_todo": {
    "prefix": "comment_todo",
    "body": "/**\n\n\tTODO:\n\t- ${1:First todo item}\n\t- ${2:Second todo item}\n\n */\n\n"
  },
  "comment_line": {
    "prefix": "comment_line",
    "body": "/* ${1:Comment} */\n\n${0}"
  },
  "comment_line_dash": {
    "prefix": "comment_line_dash",
    "body": "\n/*--------  ${1:Dash comment line}  --------*/\n${0}"
  },
  "comment_line_star": {
    "prefix": "comment_line_star",
    "body": "\n/*********  ${1:Dash comment line}  **********/\n${0}"
  },
  "comment_section": {
    "prefix": "comment_section",
    "body": [
      "\n/**================================================== *",
      " * ==========  ${1:Section comment block}  ========== *",
      " * ================================================== */\n\n$0\n",
      "/* =======  End of ${1:Section comment block}  ======= */"
    ]
  },
  "comment_section_begin": {
    "prefix": "comment_section_begin",
    "body": [
      "\n/**================================================== *",
      " * ==========  ${1:Section comment block}  ========== *",
      " * ================================================== */\n\n$0\n",
    ]
  },
  "comment_section_end": {
    "prefix": "comment_section_end",
    "body": "\n/* =======  End of ${1:Section comment block}  ======= */\n\n"
  },


  // C++ Algorithm Mnemonics

/*
	"accumulate": {
		"prefix": "acl",
		"body": [
			"auto sum = std::accumulate(std::begin(${1:container}), std::end(${1:container}), 0, [](int total, $2) {",
			"  $3",
			"});"
		]
	},
	"accumulate2": {
		"prefix": "acm",
		"body": [
			"auto sum = std::accumulate(std::begin(${1:container}), std::end(${1:container}), 0);"
		]
	},
	"adjacent_find": {
		"prefix": "ajf",
		"body": [
			"auto pos = std::adjacent_find(std::begin(${1:container}), std::end(${1:container}));",
			"if (pos != std::end(${1:container})) {",
			"  $2",
			"}"
		]
	},
	"all_of": {
		"prefix": "alo",
		"body": [
			"if (std::all_of(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"})) {",
			"  $4",
			"}"
		]
	},
	"any_of": {
		"prefix": "ano",
		"body": [
			"if (std::any_of(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"})) {",
			"  $4",
			"}"
		]
	},
	"binary_search": {
		"prefix": "bns",
		"body": [
			"auto pos = std::binary_search(std::begin(${1:container}), std::end(${1:container}), $2);",
			"if (pos != std::end(${1:container})) {",
			"  $3",
			"}"
		]
	},
	"cin": {
		"prefix": "sti",
		"body": [
			"std::cin >>"
		]
	},
	"copy": {
		"prefix": "cpy",
		"body": [
			"std::copy(std::begin(${1:container}), std::end(${1:container}), std::begin($2));"
		]
	},
	"copy2": {
		"prefix": "oit",
		"body": [
			"std::copy(std::begin(${1:container}), std::end(${1:container}), std::ostream_iterator<$2>{",
			"  std::cout, \"$3\"",
			"});"
		]
	},
	"copy_backward": {
		"prefix": "cpb",
		"body": [
			"std::copy_backward(std::begin(${1:container}), std::end(${1:container}), std::end(${1:container}));"
		]
	},
	"copy_if": {
		"prefix": "cpi",
		"body": [
			"std::copy_if(std::begin(${1:container}), std::end(${1:container}), std::begin($2),",
			"[]($3) {",
			"  $4",
			"});"
		]
	},
	"copy_n": {
		"prefix": "cpn",
		"body": [
			"std::copy_n(std::begin(${1:container}), $2, std::end(${1:container}));"
		]
	},
	"count": {
		"prefix": "cnt",
		"body": [
			"auto n = std::count(std::begin(${1:container}), std::end(${1:container}), $2);"
		]
	},
	"count_if": {
		"prefix": "cni",
		"body": [
			"auto n = std::count_if(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"});"
		]
	},
	"cout": {
		"prefix": "sto",
		"body": [
			"std::cout <<"
		]
	},
	"equal": {
		"prefix": "eql",
		"body": [
			"if (std::equal(std::begin(${1:container}), std::end(${1:container}), std::begin($2))) {",
			"  $3",
			"}"
		]
	},
	"equal_range": {
		"prefix": "eqr",
		"body": [
			"auto bounds = std::equal_range(std::begin(${1:container}), std::end(${1:container}), $2);"
		]
	},
	"equal_range2": {
		"prefix": "erl",
		"body": [
			"auto bounds = std::equal_range(std::begin(${1:container}), std::end(${1:container}), $2,",
			"  []($3,$4) { $5 });"
		]
	},
	"erase": {
		"prefix": "erm",
		"body": [
			"${1:container}.erase(std::remove(std::begin(${1:container}), std::end(${1:container}), $2), std::end(${1:container}));"
		]
	},
	"fill": {
		"prefix": "fil",
		"body": [
			"std::fill(std::begin(${1:container}), std::end(${1:container}), $2);"
		]
	},
	"fill_n": {
		"prefix": "fln",
		"body": [
			"std::fill_n(std::begin(${1:container}), $2, $3);"
		]
	},
	"find": {
		"prefix": "fnd",
		"body": [
			"auto pos = std::find(std::begin(${1:container}), std::end(${1:container}), $2);",
			"if (pos != std::end(${1:container})) {",
			"  $3",
			"}"
		]
	},
	"find_end": {
		"prefix": "fne",
		"body": [
			"auto pos = std::find_end(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3));",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"find_first_of": {
		"prefix": "ffo",
		"body": [
			"auto pos = std::find_first_of(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3));",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"find_if": {
		"prefix": "fni",
		"body": [
			"auto pos = std::find_if(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"});",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"find_if_not": {
		"prefix": "fin",
		"body": [
			"auto pos = std::find_if_not(std::begin(${1:container}), std::end(${1:container}),[]($2) {",
			"  $3",
			"});",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"for_each": {
		"prefix": "fre",
		"body": [
			"std::for_each(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"});"
		]
	},
	"generate": {
		"prefix": "gnr",
		"body": [
			"std::generate(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"});"
		]
	},
	"generate_n": {
		"prefix": "gnn",
		"body": [
			"std::generate_n(std::begin(${1:container}), $2, []($3) {",
			"  $4",
			"});"
		]
	},
	"includes": {
		"prefix": "inc",
		"body": [
			"if (std::includes(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3))) {",
			"    $4",
			"}"
		]
	},
	"inplace_merge": {
		"prefix": "ipm",
		"body": [
			"std::inplace_merge(std::begin(${1:container}), std::end(${1:container}), std::end(${1:container}));"
		]
	},
	"iota": {
		"prefix": "ita",
		"body": [
			"std::iota(std::begin(${1:container}), std::end(${1:container}), $2);"
		]
	},
	"is_heap": {
		"prefix": "ihp",
		"body": [
			"if (std::is_heap(std::begin(${1:container}), std::end(${1:container}))) {",
			"  $2",
			"}"
		]
	},
	"is_heap_until": {
		"prefix": "ihu",
		"body": [
			"auto pos = std::is_heap_until(std::begin(${1:container}), std::end(${1:container}));",
			"if (pos != std::end(${1:container})) {",
			"  $2",
			"}"
		]
	},
	"is_partitioned": {
		"prefix": "ipt",
		"body": [
			"if (std::is_partitioned(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"  })) {",
			"  $4",
			"}"
		]
	},
	"is_permutation": {
		"prefix": "ipr",
		"body": [
			"if (std::is_permutation(std::begin(${1:container}), std::end(${1:container}), std::begin($2))) {",
			"  $3",
			"}"
		]
	},
	"is_sorted": {
		"prefix": "iss",
		"body": [
			"if (std::is_sorted(std::begin(${1:container}), std::end(${1:container}))) {",
			"  $2",
			"}"
		]
	},
	"is_sorted_until": {
		"prefix": "isu",
		"body": [
			"auto pos = std::is_sorted_until(std::begin(${1:container}), std::end(${1:container}));",
			"if (pos != std::end(${1:container})) {",
			"  $2",
			"}"
		]
	},
	"lexigraphical_compare": {
		"prefix": "lxc",
		"body": [
			"if (std::lexigraphical_compare(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3)) {",
			"  $4",
			"}"
		]
	},
	"lower_bound": {
		"prefix": "lwb",
		"body": [
			"auto pos = std::lower_bound(std::begin(${1:container}), std::end(${1:container}), $2);",
			"if (pos != std::end(${1:container})) {",
			"  $3",
			"}"
		]
	},
	"make_heap": {
		"prefix": "mkh",
		"body": [
			"std::make_heap(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"max_element": {
		"prefix": "mxe",
		"body": [
			"auto pos = std::max_element(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"merge": {
		"prefix": "mrg",
		"body": [
			"std::merge(std::begin(${1:container}), std::end(${1:container}),",
			"std::begin($2), std::end($3), std::begin($4));"
		]
	},
	"minmax_element": {
		"prefix": "mme",
		"body": [
			"auto minmax = std::minmax_element(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"min_element": {
		"prefix": "mne",
		"body": [
			"auto pos = std::min_element(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"mismatch": {
		"prefix": "msm",
		"body": [
			"auto values = std::mismatch(std::begin(${1:container}), std::end(${1:container}), std::begin(${1:container}));",
			"if (values.first == std::end(${1:container})) {",
			"  $2",
			"} else {",
			"  $3",
			"}"
		]
	},
	"move": {
		"prefix": "mov",
		"body": [
			"std::move(std::begin(${1:container}), std::end(${1:container}), std::begin(${1:container}));"
		]
	},
	"move_backward": {
		"prefix": "mvb",
		"body": [
			"std::move_backward(std::begin(${1:container}), std::end(${1:container}), std::end(${1:container}));"
		]
	},
	"next_permutation": {
		"prefix": "nxp",
		"body": [
			"if (std::next_permutation(std::begin(${1:container}), std::end(${1:container}))) {",
			"  $2",
			"}"
		]
	},
	"none_of": {
		"prefix": "nno",
		"body": [
			"if (std::none_of(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"})) {",
			"  $4",
			"}"
		]
	},
	"nth_element": {
		"prefix": "nth",
		"body": [
			"std::nth_element(std::begin(${1:container}), std::end(${1:container}), std::end(${1:container}));"
		]
	},
	"partition": {
		"prefix": "ptn",
		"body": [
			"auto pos = std::partition(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"});",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"partition_copy": {
		"prefix": "ptc",
		"body": [
			"std::partition_copy(std::begin(${1:container}), std::end(${1:container}),",
			"                  std::begin($2), std::end($3));"
		]
	},
	"partition_point": {
		"prefix": "ppt",
		"body": [
			"auto pos = std::partition_point(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"});",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"partial_sort": {
		"prefix": "pst",
		"body": [
			"std::partial_sort(std::begin(${1:container}), std::end(${1:container}), std::end(${1:container}));"
		]
	},
	"partial_sort_copy": {
		"prefix": "psc",
		"body": [
			"std::partial_sort_copy(std::begin(${1:container}), std::end(${1:container}),",
			"                  std::begin($2), std::end($3));"
		]
	},
	"pop_heap": {
		"prefix": "pph",
		"body": [
			"std::pop_heap(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"prev_permutation": {
		"prefix": "prp",
		"body": [
			"if (std::prev_permutation(std::begin(${1:container}), std::end(${1:container}))) {",
			"  $2",
			"}"
		]
	},
	"push_heap": {
		"prefix": "phh",
		"body": [
			"std::push_heap(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"random_shuffle": {
		"prefix": "shf",
		"body": [
			"std::random_shuffle(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"remove": {
		"prefix": "rmv",
		"body": [
			"auto pos = std::remove(std::begin(${1:container}), std::end(${1:container}), $2);",
			"if (pos != std::end(${1:container})) {",
			"  $3",
			"}"
		]
	},
	"remove_copy": {
		"prefix": "rmc",
		"body": [
			"std::remove_copy(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin(${1:container}), $2);"
		]
	},
	"replace": {
		"prefix": "rpl",
		"body": [
			"std::replace(std::begin(${1:container}), std::end(${1:container}), $2, $3);"
		]
	},
	"remove_copy_if": {
		"prefix": "rmf",
		"body": [
			"std::remove_copy_if(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin(${1:container}), []($2) {",
			"    $3",
			"});"
		]
	},
	"remove_if": {
		"prefix": "rmi",
		"body": [
			"auto pos = std::remove_if(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"});",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"replace_copy": {
		"prefix": "rpc",
		"body": [
			"std::replace_copy(std::begin(${1:container}), std::end(${1:container}), std::begin(${1:container}), $2, $3);"
		]
	},
	"replace_copy_if": {
		"prefix": "rci",
		"body": [
			"std::replace_copy_if(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin(${1:container}), []($2) {",
			"  $3",
			"  }, $4);"
		]
	},
	"replace_if": {
		"prefix": "rpi",
		"body": [
			"std::replace_if(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3",
			"}, $4);"
		]
	},
	"reverse": {
		"prefix": "rvr",
		"body": [
			"std::reverse(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"reverse_copy": {
		"prefix": "rvc",
		"body": [
			"std::reverse_copy(std::begin(${1:container}), std::end(${1:container}), std::begin($2));"
		]
	},
	"rotate": {
		"prefix": "rte",
		"body": [
			"std::rotate(std::begin(${1:container}), std::begin($2), std::end(${1:container}));"
		]
	},
	"rotate_copy": {
		"prefix": "rtc",
		"body": [
			"std::rotate_copy(std::begin(${1:container}), std::begin($2), std::end(${1:container}),",
			"  std::begin($3));"
		]
	},
	"search": {
		"prefix": "srh",
		"body": [
			"auto pos = std::search(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3));",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"search_n": {
		"prefix": "srn",
		"body": [
			"auto pos = std::search_n(std::begin(${1:container}), std::end(${1:container}),$2,$3);",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"set_intersection": {
		"prefix": "stn",
		"body": [
			"auto pos = std::set_intersection(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3), std::begin($4));"
		]
	},
	"set_difference": {
		"prefix": "std",
		"body": [
			"auto pos = std::set_difference(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3), std::begin($4));"
		]
	},
	"set_symmetric_difference": {
		"prefix": "ssd",
		"body": [
			"auto pos = std::set_symmetric_difference(std::begin(${1:container}),",
			"  std::end(${1:container}), std::begin($2), std::end($3), std::begin($4));"
		]
	},
	"set_union": {
		"prefix": "stu",
		"body": [
			"auto pos = std::set_union(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin($2), std::end($3), std::begin($4));"
		]
	},
	"sort": {
		"prefix": "srt",
		"body": [
			"std::sort(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"sort_heap": {
		"prefix": "sth",
		"body": [
			"std::sort_heap(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"stable_partition": {
		"prefix": "spt",
		"body": [
			"auto pos = std::stable_partition(std::begin(${1:container}), std::end(${1:container}), []($2) {",
			"  $3});",
			"if (pos != std::end(${1:container})) {",
			"  $4",
			"}"
		]
	},
	"stable_sort": {
		"prefix": "sts",
		"body": [
			"std::stable_sort(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"string_lower": {
		"prefix": "lwr",
		"body": [
			"std::transform(std::begin(${1:container}), std::end(${1:container}), std::begin(${1:container}), [](char c) {",
			"return std::tolower(c); });"
		]
	},
	"string_upper": {
		"prefix": "upr",
		"body": [
			"std::transform(std::begin(${1:container}), std::end(${1:container}), std::begin(${1:container}), [](char c) {",
			"return std::toupper(c);",
			"});",
			"$2"
		]
	},
	"string_trim_left": {
		"prefix": "ltr",
		"body": [
			"${1:container}.erase(0, ${1:container}.find_first_not_of(\" \\t\\n\\r\"));"
		]
	},
	"string_trim_right": {
		"prefix": "trm",
		"body": [
			"${1:container}.erase(${1:container}.find_last_not_of(\" \\t\\n\\r\") + 1);"
		]
	},
	"swap": {
		"prefix": "swp",
		"body": [
			"std::swap(${1:container}, $2);"
		]
	},
	"swap_ranges": {
		"prefix": "swr",
		"body": [
			"std::swap_ranges(std::begin(${1:container}), std::end(${1:container}), std::begin($2));"
		]
	},
	"transform": {
		"prefix": "tfm",
		"body": [
			"std::transform(std::begin(${1:container}), std::end(${1:container}),",
			"  std::begin(${1:container}), []($2) {",
			"$3",
			"});"
		]
	},
	"unique": {
		"prefix": "uqe",
		"body": [
			"auto pos = std::unique(std::begin(${1:container}), std::end(${1:container}));"
		]
	},
	"unique_copy": {
		"prefix": "ucp",
		"body": [
			"std::unique_copy(std::begin(${1:container}), std::end(${1:container}),",
			"  std::ostream_iterator<string>(std::cout, \"\\n\"));"
		]
	},
	"upper_bound": {
		"prefix": "upb",
		"body": [
			"auto pos = std::upper_bound(std::begin(${1:container}), std::end(${1:container}), $2);",
			"if (pos != std::end(${1:container})) {",
			"  $3",
			"}"
		]
	},
	"vector": {
		"prefix": "stv",
		"body": [
			"std::vector<$2> $3"
		]
	}
*/
}
